---
title: "GCAT base tutorial"
author: Markus Gumbel
date: "`r format(Sys.time(), '%d. %B %Y')`"
params:
  devel: TRUE
output:
 html_document:
  toc: true
  number_sections: true 
---

Under construction.

```{r include=params$devel, eval=params$devel}
devtools::load_all(".")
```

```{r include=!params$devel, eval=!params$devel}
library(gcatbase)
```

# Sequence, tuple and codon representations

Tuples can be created with the `tuples` function.

(`rextendr` does not have parameter names, does it?)

```{r}
codons = all_tuples(3)
print(codons)
```

There are many ways to represent nucleotide sequences and codons or tuples in general:

 * DNA or RNA?
 * letters in lower- or upper-case?
 * Sequences as string or as vector of characters?

 `gcat-base` offers functions to convert the representation. The default representation is DNA in upper-case.

`normalize` converts a sequence or a vector of sequences (e.g. codons) to a specified representation.
```{r eval=F}
rna_codons = normalize(codons, nuc = "RNA", lowercase = T)
print(rna_codons)
```

Note: a tuple or a codon is a special case of a nucleotide sequence.

# Codes

## Create codes (`code`)

Codes are created with the `code` function. If the tuples passed to `code` are not unique they are made unique.

```{r}
# Non unique tuple set:
X = code(tuples = c("ATG", "GCG", "ATG"), id = "A code")
```

This will return an object of type `gcat.code`. The attributes are:

 * `id`: a short identifier for this code.
 * `tuples`: unique vector of tuples.
 * `tsize`: tuple size (e.g. 3 if codons)

Note that the code is now unique. The elements are sorted.
```{r}
print(X)
```

In particular for codons the `summary` function is available.

```{r}
print(summary(X))
```

## Random codes (`random.code`)

It is also possible to create random codes.

```{r}
Xr = random.code(size = 10, tsize = 4)
print(Xr)
```

## Persisting codes in a text file

Codes can be written to and read from a file.

```{r}
write.codes(filename = "codes.txt", codes = list(X))
```

```{r}
X2 = read.codes("codes.txt")
print(X2)
```


# Manipulation of sequences, tuples and codons

## Tuples from a sequence

```{r}
seq = "ATCATGACGGCGCGGAGGATAGCGAGCAGGT"
t = gcatbase::split(seq, 3)
print(t)
```

Next we want to calculate the tuple usage. `tuples.usage` creates a data frame.
```{r}
u = tuples.freq(t)
print(head(u, 10))
```

Make a code from the sequence. Note that `code` makes the tuples unique:
```{r}
X2 = code(t, "Code from seq.")
print(X2)
```

## Shift tuples

```{r}
X2s = code(shift(1, X2$tuples), "shifted code")
print(X2s)
```

## Strip complements

```{r eval=F}
strip_complements(X)
```

## Classify sequence according to a code

```{r}
h = classify(seq, X)
print(h)
```

From this we can derive the code usage $u$ (in %)
```{r}
u = length(h[h == 1]) / length(h)
print(u)
```

or use the convenient function `code.usage`:

```{r}
u = code.usage(seq, X)
print(u)
```

# Amino acids

We can translate a vector of codons into amino acids:
```{r}
print(amino.acids(t))
```

Also, we can ask what amino acids are used by a code. Here the Vertebrate Mitochondrial Code (transl_table = 2) is used:
```{r}
print(amino.acids(X, numcode = 2)) # generic for amino.acids(X$tuples)
```